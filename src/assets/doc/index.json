{
  "project": "Neureka",
  "version": "0.17.0",
  "created": "Tue Aug 02 21:06:08 CEST 2022",
  "statistics":{
    "runs":"78",
    "passed":"77",
    "failed":"0",
    "featureFailures":"0",
    "successRate":"1.0",
    "duration":"117851.0"
  },
  "specifications": [{
      "className":"Example_Spec.Example_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"180",
      "executedFeatures":[{"id":"Call me feature not unit test!","extraInfo":[]},{"id":"I am readable and also best practice!","extraInfo":[]},{"id":"Numbers to the power of two with a fancy data table!","extraInfo":[]},{"id":"Should be able to remove from list","extraInfo":[]},{"id":"iAmNotSoReadable","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.AD_And_Computation_Graph_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"964",
      "executedFeatures":[{"id":"Payloads and derivatives are null after garbage collection.","extraInfo":[]},{"id":"Reshaping produces expected computation graph and also works with reverse mode AD.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.internal.GraphNode_Instantiation_Unit_Tests",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"1826",
      "executedFeatures":[{"id":"GraphNode instantiation works as expected when the context argument is a GraphLock.","extraInfo":[]},{"id":"GraphNode instantiation works as expected when the context argument is an ExecutionCall.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.Backend_MatMul_Extension_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"444",
      "executedFeatures":[{"id":"GEMM matrix multiplication reference implementation can be set as custom OperationType and works as expected.","extraInfo":[]},{"id":"Test context mock for opencl reference implementations.","extraInfo":[]},{"id":"Tile parsing for kernel parameter calculation yields expected tile dimensions.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.exceptions.Tensor_Exception_Spec",
      "featureCount":"8",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"369",
      "executedFeatures":[{"id":"Building a tensor with \"null\" as shape argument throws an exception.","extraInfo":[]},{"id":"Building a tensor with 0 shape arguments throws an exception.","extraInfo":[]},{"id":"Casting a tensor as something unusual will cuas an exception to be thrown.","extraInfo":[]},{"id":"Out of dimension bound causes descriptive exception!","extraInfo":[]},{"id":"Passing an invalid key object into the \"getAt\" method causes a descriptive exception.","extraInfo":[]},{"id":"Passing an invalid object into Tsr constructor causes descriptive exception.","extraInfo":[]},{"id":"Passing null to various methods of the tensor API will throw exceptions.","extraInfo":[]},{"id":"Trying to inject an empty tensor into another causes fitting exception.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Fluent_Tensor_Creation_Spec",
      "featureCount":"7",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"177",
      "executedFeatures":[{"id":"Initialization lambda based tensors can be created fluently.","extraInfo":[]},{"id":"Range based tensors can be created fluently.","extraInfo":[]},{"id":"Scalars can be created fluently.","extraInfo":[]},{"id":"Seed based tensors can be created fluently.","extraInfo":[]},{"id":"Tensors can be created fluently.","extraInfo":[]},{"id":"Value based tensors can be created fluently.","extraInfo":[]},{"id":"Vectors can be created fluently.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Gradient_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"37",
      "executedFeatures":[{"id":"Gradient of tensor is being applies regardless of the tensor requiring gradient or not","extraInfo":[]},{"id":"Tensors can have gradients but not require them.","extraInfo":[]},{"id":"Tensors that have gradients but do not require them still print them.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Version_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"848",
      "executedFeatures":[{"id":"Inline operations cause illegal state exceptions.","extraInfo":[]},{"id":"Inline operations causes version incrementation.","extraInfo":[]},{"id":"Non-inline operations do not cause version incrementation.","extraInfo":[]},{"id":"Storing a tensor on a device should not change the version of a tensor (Even though its data changed technically).","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.Autograd_Flags_Explained",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"1002",
      "executedFeatures":[{"id":"Advanced backpropagation on all AD-Modes ","extraInfo":[]},{"id":"We can create a shallow copy of a tensor detached from the computation graph.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.Autograd_NN_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"1672",
      "executedFeatures":[{"id":"Autograd work for simple matrix multiplications.","extraInfo":[]},{"id":"Autograd works for 2 matrix multiplications in a row.","extraInfo":[]},{"id":"Autograd works in a simple convolutional dot product and float based feed forward neural network.","extraInfo":[]},{"id":"Autograd works in a simple convolutional dot product based feed forward neural network.","extraInfo":[]},{"id":"Autograd works in a simple mat-mul based feed forward neural network.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.JITProp_Autograd_Tensor_Spec",
      "featureCount":"8",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"286",
      "executedFeatures":[{"id":"Gradient auto-apply kicks in when used AD uses JIT prop","extraInfo":[]},{"id":"Test JIT propagation variant one.","extraInfo":[]},{"id":"Test JIT propagation variant two.","extraInfo":[]},{"id":"Test autograd without JIT and auto apply.","extraInfo":[]},{"id":"Test in-differential and JIT with auto apply","extraInfo":[]},{"id":"Test no JIT prop when forward AD","extraInfo":[]},{"id":"Test no preemptive gradient apply when not requested and auto apply and JIT_prop","extraInfo":[]},{"id":"Test pending error optimization","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.core.Randomization_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"108",
      "executedFeatures":[{"id":"Randomization is in essence the same algorithm as JDKs \"Random\".","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.OpenCLDevice_Exception_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"2249",
      "executedFeatures":[{"id":"Ad hoc compilation produces expected exceptions when duplication is found.","extraInfo":[]},{"id":"Ad hoc compilation produces expected exceptions.","extraInfo":[]},{"id":"An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","extraInfo":[]},{"id":"Trying to restore a tensor which is not on a device raises exception.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.ndim.Tensor_NDConfiguration_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"73",
      "executedFeatures":[{"id":"NDConfiguration instances of tensors have expected state and behaviour.","extraInfo":[]},{"id":"NDConfiguration instances of tensors have expected state.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Slicing_Spec",
      "featureCount":"9",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"200",
      "executedFeatures":[{"id":"A tensor can be sliced by passing ranges in the form of lists (Groovy ranges).","extraInfo":[]},{"id":"A tensor can be sliced by passing ranges in the form of primitive arrays.","extraInfo":[]},{"id":"Normal slicing will try to do autograd.","extraInfo":[]},{"id":"Slicing is also a Function with autograd support!","extraInfo":[]},{"id":"The \"at\" method and the \"from\" / \"to\" methods can be mixed when slicing a tensor.","extraInfo":[]},{"id":"The slice builder also supports slicing with custom step sizes.","extraInfo":[]},{"id":"We can avoid autograd when slicing by using the \"detached\" instead of the \"get\" method.","extraInfo":[]},{"id":"We can slice a scalar tensor from a larger tensor of rank 4.","extraInfo":[]},{"id":"When Slicing only one axis using the SliceBuilder API, the other axes will be sliced implicitly.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"it.Calculus_Stress_Test",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"6731",
      "executedFeatures":[{"id":"Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.","extraInfo":[]},{"id":"Activation functions work across types.","extraInfo":[]},{"id":"Dot operation stress test runs error free and produces expected result","extraInfo":[]},{"id":"Stress test runs error free and produces expected result","extraInfo":[]},{"id":"The broadcast operation stress test runs error free and produces expected result","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.Autograd_Tensor_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"139",
      "executedFeatures":[{"id":"A tensor used as derivative within a computation graph will throw exception when trying to deleting it.","extraInfo":[]},{"id":"Second-Test \"x-mul\" autograd behaviour. (Not on device)","extraInfo":[]},{"id":"Test basic autograd behaviour. (Not on device)","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_As_Container_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"74",
      "executedFeatures":[{"id":"More tensor operations translate to custom data type \"ComplexNumber\".","extraInfo":[]},{"id":"Plus operator on String tensors works element-wise.","extraInfo":[]},{"id":"Tensor operations translate to custom data type \"ComplexNumber\".","extraInfo":[]},{"id":"We can apply predicates on the values of a tensor.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_State_Spec",
      "featureCount":"8",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"216",
      "executedFeatures":[{"id":"A tensor can be instantiated from a target type and nested lists.","extraInfo":[]},{"id":"Newly instantiated and unmodified scalar tensor has expected state.","extraInfo":[]},{"id":"Newly instantiated and unmodified vector tensor has expected state.","extraInfo":[]},{"id":"Numeric tensors as String can be formatted on an entry based level.","extraInfo":[]},{"id":"Tensor created from shape and datatype has expected state.","extraInfo":[]},{"id":"Tensors as String can be formatted depending on shape.","extraInfo":[]},{"id":"Tensors as String can be formatted on an entry based level.","extraInfo":[]},{"id":"The data and the value of a tensor a 2 different things!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.utility.Cleaner_Testing",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"326",
      "executedFeatures":[{"id":"The default DeviceCleaner works","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.utility.ListReader_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"27",
      "executedFeatures":[{"id":"The ListReader can interpret nested lists into a shape list and value list.","extraInfo":[]},{"id":"The ListReader can interpret nested lists resembling a 3D tensor into a shape list and value list.","extraInfo":[]},{"id":"The ListReader can interpret nested lists resembling a matrix into a shape list and value list.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.utility.Utility_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"61",
      "executedFeatures":[{"id":"Object arrays can be converted to primitive arrays.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"it.Eleven_Lines_NN_System_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"6706",
      "executedFeatures":[{"id":"One can write a simple double based neural network in less than 11 lines of java like code using the \"@\" operator!","extraInfo":[]},{"id":"One can write a simple float based neural network in less than 11 lines of java like code!","extraInfo":[]},{"id":"One can write a simple neural network in less than 11 lines of code!","extraInfo":[]},{"id":"One can write a simple neural network with custom back-prop in 11 lines of code!","extraInfo":[]},{"id":"The pseudo random number generator works as expected for the weights used in the 11 line NN examples!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"st.Broad_System_Test",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"270",
      "executedFeatures":[{"id":"Test integration broadly.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.internal.GraphNode_Instantiation_Exception_Unit_Tests",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"2325",
      "executedFeatures":[{"id":"GraphNode instantiation throws exception because GraphNode instances of input tensors do not share the same GraphLock.","extraInfo":[]},{"id":"GraphNode instantiation throws exception because tensors of ExecutionCall do not return GraphNode instances.","extraInfo":[]},{"id":"GraphNode throws an exception when trying to execute an inline operation on inputs with active autograd.","extraInfo":[]},{"id":"GraphNode throws an exception when trying to instantiate it with the wrong context.","extraInfo":[]},{"id":"GraphNode throws exception when payload is null.","extraInfo":[]},{"id":"GraphNode throws exception when trying to instantiate it with the Function argument being null.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.Backend_Extension_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"298",
      "executedFeatures":[{"id":"Lambda properties of mock implementation interact with FunctionNode as expected.","extraInfo":[]},{"id":"Mock operation interacts with FunctionNode (AbstractFunction) instance as expected.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.Matrix_Multiplication_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"107",
      "executedFeatures":[{"id":"The simple CPU matrix multiplication implementation works as expected.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.CPU_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"620",
      "executedFeatures":[{"id":"CPU knows the current number of available processor cores!","extraInfo":[]},{"id":"The CPU exposes a non null API for executing workloads in parallel.","extraInfo":[]},{"id":"Thread pool executes given workload in parallel","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.dtype.NumericType_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"237",
      "executedFeatures":[{"id":"Conversion goes both ways and produces expected numeric values.","extraInfo":[]},{"id":"NumericType conversion to holder types yields expected results.","extraInfo":[]},{"id":"NumericType implementations behave as expected.","extraInfo":[]},{"id":"NumericType implementations return their expected properties.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.framing.Tensor_Framing_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"313",
      "executedFeatures":[{"id":"Added labels to tensors are accessible through the \"index()\" method.","extraInfo":[]},{"id":"Rank 2 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","extraInfo":[]},{"id":"Rank 3 tensors can be labeled and their labels can be used to extract slices / subsets of tensors.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.ndim.Tensor_Reshape_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"7",
      "executedFeatures":[{"id":"When matrices are transpose, they will change their layout type.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.optimization.RMSprop_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"56",
      "executedFeatures":[{"id":"RMSprop optimizes according to expected inputs","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Device_Mock_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"28",
      "executedFeatures":[{"id":"Tensors try to migrate themselves to a device that is being added to them as component.","extraInfo":[]},{"id":"Tensors try to remove themselves from their device when \"setIsOutsourced(false)\" is being called.","extraInfo":[]},{"id":"The device of a tensor can be accessed via the \"device()\" method.","extraInfo":[]},{"id":"When creating slices of tensors then this should trigger a \"parent - child\" relation noticeable to the device!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.core.Backend_Functional_Algorithm_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"3142",
      "executedFeatures":[{"id":"A functional algorithm cannot be used if it was not built properly!","extraInfo":[]},{"id":"A functional algorithm does not accept null as an answer!","extraInfo":[]},{"id":"A functional algorithm warns us when modified after it has been built!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.BackendContext_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"95",
      "executedFeatures":[{"id":"BackendContext instances can be created by cloning from Singleton instance.","extraInfo":[]},{"id":"BackendContext instances return Runner instances for easy visiting with return values.","extraInfo":[]},{"id":"BackendContext instances return Runner instances for easy visiting.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.internal.OpenCL_Data_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"392",
      "executedFeatures":[{"id":"The \"Data\" class can represent various OpenCL data types.","extraInfo":[]},{"id":"The OpenCLDevice specific Data class represents JVM data for OpenCL.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.ndim.Tensor_Slice_Reshape_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"524",
      "executedFeatures":[{"id":"A slice of a tensor changes as expected when reshaping it.","extraInfo":[]},{"id":"Reshaping a slice works as expected.","extraInfo":[]},{"id":"Two slices of one big tensor perform matrix multiplication flawless.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Functional_Tensor_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"2315",
      "executedFeatures":[{"id":"Tensor initialization lambdas produce expected tensors.","extraInfo":[]},{"id":"Tensor mapping lambdas produce expected tensors.","extraInfo":[]},{"id":"The \"map\" method is a shorter convenience method for mapping to the same type.","extraInfo":[]},{"id":"We can analyse the values of a tensor using various predicate receiving methods","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Generics_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"41",
      "executedFeatures":[{"id":"1D tensors can be created from primitive arrays.","extraInfo":[]},{"id":"Anonymous tensor instance has the default datatype class as defined in Neureka settings.","extraInfo":[]},{"id":"String tensor instance discovers expected class.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_IO_Spec",
      "featureCount":"16",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"440",
      "executedFeatures":[{"id":"A tensor produced by a function has expected properties.","extraInfo":[]},{"id":"A tensor produced by the static \"Tsr.Create.newRandom(shape)\" has expected \"random\" value.","extraInfo":[]},{"id":"Adding OpenCL device to tensor makes tensor be \"outsourced\" and contain the Device instance as component.","extraInfo":[]},{"id":"Indexing after reshaping works as expected.","extraInfo":[]},{"id":"Passing String seed to tensor produces expected values.","extraInfo":[]},{"id":"Smart tensor constructors yield expected results.","extraInfo":[]},{"id":"Tensor value type can not be changed by passing float or double arrays to it.","extraInfo":[]},{"id":"Tensor values can be manipulated via static method calls within the \"Tsr.IO\" class.","extraInfo":[]},{"id":"Tensors can be instantiated with String seed.","extraInfo":[]},{"id":"Tensors value type can be changed by calling \"toType(...)\".","extraInfo":[]},{"id":"The tensor data array can be modified by targeting them with an index.","extraInfo":[]},{"id":"Vector tensors can be instantiated via factory methods.","extraInfo":[]},{"id":"We can manipulate the underlying data array of a tensor through the unsafe API.","extraInfo":[]},{"id":"We can re-populate a tensor of shorts from a single scalar value!","extraInfo":[]},{"id":"We turn a tensor into a scalar value or string through the \"as\" operator!","extraInfo":[]},{"id":"When we try to manipulate the underlying data array of a virtual tensor then it will become actual.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Layout_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"851",
      "executedFeatures":[{"id":"A new transposed version of a given tensor will be returned by the \"T()\" method.","extraInfo":[]},{"id":"Matrix multiplication works for both column and row major matrices across devices.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.utility.DataConverter_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"12",
      "executedFeatures":[{"id":"An array of any type of object may be converted to a array of primitives.","extraInfo":[]},{"id":"The DataConverter can convert the given array data.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"it.Cross_Device_Sliced_Tensor_System_Test",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"4577",
      "executedFeatures":[{"id":"Cross device sliced tensor integration test runs without errors.","extraInfo":[]},{"id":"Slices can be created using the SliceBuilder.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.Calculus_Exception_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"50",
      "executedFeatures":[{"id":"Function throws exception when arity does not match input number.","extraInfo":[]},{"id":"Function throws exception when not enough inputs provided.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.Tensor_Function_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"733",
      "executedFeatures":[{"id":"Executed tensors are intermediate tensors.","extraInfo":[]},{"id":"Reshaping on 3D tensors works by instantiate a Function instance built from a String.","extraInfo":[]},{"id":"Tensor results of various Function instances return expected results.","extraInfo":[]},{"id":"The \"DimTrim\" operation works forward as well as backward!","extraInfo":[]},{"id":"The optimization function for the SGD algorithm produces the expected result","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.Cross_Device_IO_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"161",
      "executedFeatures":[{"id":"We can use the access device API to read from a tensor.","extraInfo":[]},{"id":"We can use the access device API to write to a tensor","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.FileDevice_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"280",
      "executedFeatures":[{"id":"A file device stores tensors in idx files by default.","extraInfo":[]},{"id":"A file device stores tensors in various file formats.","extraInfo":[]},{"id":"The file device can load known files in a directory.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.internal.OpenCL_GEMM_Unit_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"1516",
      "executedFeatures":[{"id":"The GEMM implementation for the OpenCLDevice has realistic behaviour","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.optimization.ADAM_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"206",
      "executedFeatures":[{"id":"ADAM optimizes according to expected inputs","extraInfo":[]},{"id":"Equations \"I[0]*I[1]+(1-I[2])*I[3]\" and \"(1-I[0])*I[1]\" used within ADAM return expected results.","extraInfo":[]},{"id":"Equations used by ADAM return expected result.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.utility.FileHandle_Spec",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"767",
      "executedFeatures":[{"id":"Fully labeled tenors will be stored with their labels included when saving them as CSV.","extraInfo":[]},{"id":"Partially labeled tenors will be stored with their labels included when saving them as CSV.","extraInfo":[]},{"id":"Test reading IDX file format.","extraInfo":[]},{"id":"Test writing IDX file format.","extraInfo":[]},{"id":"The FileDevice component \"CSVHead\" can read CSV file formats and load them as tensors.","extraInfo":[]},{"id":"We can load image files as tensors.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.core.Backend_Algorithm_AD_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"2708",
      "executedFeatures":[{"id":"Activation implementations behave as expected.","extraInfo":[]},{"id":"Broadcast implementations behave as expected.","extraInfo":[]},{"id":"Convolution implementations behave as expected.","extraInfo":[]},{"id":"Operator implementations behave as expected.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.Calculus_Function_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"283",
      "executedFeatures":[{"id":"Function implementations ensure that internally created tensors are flagged as \"intermediate\" initially!","extraInfo":[]},{"id":"Function implementations ensure that outputs which are input members are not flagged as \"intermediate\"!","extraInfo":[]},{"id":"Function implementations will ensure the \"call\" and \"invoke\" does not return tensors flagged as \"intermediate\".","extraInfo":[]},{"id":"The library context exposes a set of useful functions.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.Cross_Device_Type_Spec",
      "featureCount":"10",
      "failures":"0",
      "errors":"0",
      "skipped":"1" ,
      "successRate":"1.0",
      "duration":"863",
      "executedFeatures":[{"id":"Advanced device querying methods query as expected!","extraInfo":[]},{"id":"Devices store slices which can also be restored.","extraInfo":[]},{"id":"Devices store tensors which can also be restored.","extraInfo":[]},{"id":"Execution calls containing null arguments will cause an exception to be thrown in device instances.","extraInfo":[]},{"id":"Passing a numeric array to a tensor should modify its content!","extraInfo":[]},{"id":"Querying for Device implementations works as expected.","extraInfo":[]},{"id":"Tensor data can be fetched from device if the tensor is stored on it...","extraInfo":[]},{"id":"The simpler device querying methods query as expected!","extraInfo":[]},{"id":"Virtual tensors stay virtual when outsourced.","extraInfo":[]}],
      "ignoredFeatures":[{"id":"Devices cannot store slices which parents are not already stored.","extraInfo":[]}]
    },{
      "className":"ut.device.OpenCLDevice_Spec",
      "featureCount":"8",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"8465",
      "executedFeatures":[{"id":"Ad hoc compilation produces executable kernel.","extraInfo":[]},{"id":"Ad hoc compilation works for WIP general purpose matrix multiplication.","extraInfo":[]},{"id":"Ad hoc compilation works for custom column major based tiled matrix multiplication.","extraInfo":[]},{"id":"Ad hoc compilation works for custom simple row major based matrix multiplication.","extraInfo":[]},{"id":"Ad hoc matrix multiplication works for multiple of 16 matrices.","extraInfo":[]},{"id":"An OpenCLDevice loads tensors in a provided lambda temporarily.","extraInfo":[]},{"id":"The \"getData()\" method of an outsourced tensor will return null when outsourced.","extraInfo":[]},{"id":"The \"getValue()\" method of an outsourced tensor will return the expected array type.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.neureka.Neureka_Spec",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"7367",
      "executedFeatures":[{"id":"Backend related library objects adhere to the same toString formatting convention!","extraInfo":[]},{"id":"Every Thread instance has their own Neureka instance.","extraInfo":[]},{"id":"Neureka class instance has expected behaviour.","extraInfo":[]},{"id":"Neureka settings class can be locked causing its properties to be immutable.","extraInfo":[]},{"id":"OpenCL related library objects adhere to the same toString formatting convention!","extraInfo":[]},{"id":"Various library objects adhere to the same toString formatting convention!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.optimization.Momentum_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"37",
      "executedFeatures":[{"id":"Momentum optimizes according to expected inputs","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Convolution_Spec",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"739",
      "executedFeatures":[{"id":"Autograd works with simple 2D convolution.","extraInfo":[]},{"id":"Manual convolution produces expected result.","extraInfo":[]},{"id":"Sime convolution works as expected eith autograd.","extraInfo":[]},{"id":"Tensors have the correct layout after convolution.","extraInfo":[]},{"id":"The \"x\" (convolution) operator produces expected results (On the CPU).","extraInfo":[]},{"id":"Very simple manual convolution produces expected result.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Interop_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"34",
      "executedFeatures":[{"id":"Not all tensor can be converted to images.","extraInfo":[]},{"id":"Tensor can be converted to buffered images.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"st.Benchmark_System_Test",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"10300",
      "executedFeatures":[{"id":"Tensor can be constructed by passing List instances.","extraInfo":[]},{"id":"Test benchmark script and simple tensor constructor.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.core.Matrix_Multiplication_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"862",
      "executedFeatures":[{"id":"The internal matrix multiplication test script runs!","extraInfo":[]},{"id":"The simple CPU matrix multiplication implementation works as expected.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.Calculus_Scalar_Spec",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"105",
      "executedFeatures":[{"id":"Function \"(I[0]+1/I[0])**-I[0]\" instance returns expected scalar result.","extraInfo":[]},{"id":"Function \"(cos(I[0]*5)/5+I[0])*(1+sin(I[0])/2)\" instance returns expected scalars.","extraInfo":[]},{"id":"Function \"1/I[0]\" instance returns expected scalar results.","extraInfo":[]},{"id":"Function \"I[0]+1/I[0]\" instance returns expected scalar results.","extraInfo":[]},{"id":"Test scalar results of Function \"sumjs((cos(I[j]*5)/5+I[j])*(1+sin(I[j])/2))\" instance.","extraInfo":[]},{"id":"Test scalar results of various Function instances.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.internal.CLFunctionCompiler_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"269",
      "executedFeatures":[{"id":"The CLFunctionCompiler produces an operation which properly integrates to the backend.","extraInfo":[]},{"id":"The CLFunctionCompiler produces the expected \"ad hoc\" kernel.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.dtype.DataType_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"22",
      "executedFeatures":[{"id":"DataType multi-ton instances behave as expected.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.optimization.AdaGrad_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"52",
      "executedFeatures":[{"id":"AdaGrad optimizes according to expected inputs","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.optimization.Optimizer_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"1" ,
      "successRate":"1.0",
      "duration":"2",
      "executedFeatures":[],
      "ignoredFeatures":[{"id":"Conv dot based feed forward and activation produces expected result.","extraInfo":[]}]
    },{
      "className":"ut.tensors.exceptions.Tensor_Delete_Exception_Spec",
      "featureCount":"7",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"36",
      "executedFeatures":[{"id":"A deleted tensor will tell you that it has been deleted.","extraInfo":[]},{"id":"A deleted tensor will throw an exception when accessing its configuration.","extraInfo":[]},{"id":"A deleted tensor will throw an exception when accessing its data type.","extraInfo":[]},{"id":"A deleted tensor will throw an exception when accessing its data.","extraInfo":[]},{"id":"A deleted tensor will throw an exception when modifying its data type.","extraInfo":[]},{"id":"A deleted tensor will throw an exception when trying to modify its data.","extraInfo":[]},{"id":"A deleted tensor will throw an exception when trying to set its configuration.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Tensor_Operation_Spec",
      "featureCount":"11",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"10769",
      "executedFeatures":[{"id":"Activation functions work across types on slices and non sliced tensors.","extraInfo":[]},{"id":"Auto reshaping and broadcasting works and the result can be back propagated.","extraInfo":[]},{"id":"New method \"asFunction\" of String added at runtime is callable by groovy and also works.","extraInfo":[]},{"id":"New operator methods added to \"SDK-types\" at runtime are callable by groovy and also work.","extraInfo":[]},{"id":"Operators \"+,*,**\" produce expected results with gradients which can be accessed via a \"Ig[0]\" Function instance","extraInfo":[]},{"id":"Overloaded operation methods on tensors produce expected results when called.","extraInfo":[]},{"id":"Simple slice addition produces expected result.","extraInfo":[]},{"id":"The \"dot\" operation reshapes and produces valid \"x\" operation result.","extraInfo":[]},{"id":"The \"matMul\" operation produces the expected result.","extraInfo":[]},{"id":"The \"random\" function/operation populates tensors randomly.","extraInfo":[]},{"id":"The values of a randomly populated tensor seems to adhere to a gaussian distribution.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"it.Cross_Device_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"25966",
      "executedFeatures":[{"id":"A gradient of ones can be set by calling the backward method on a tensor sitting on any device.","extraInfo":[]},{"id":"Convolution can model matrix multiplications across devices.","extraInfo":[]},{"id":"Mapping tensors works for every device (even if they are not used).","extraInfo":[]},{"id":"Test cross device system test runs successfully.","extraInfo":[]},{"id":"Test simple NN implementation with manual backprop","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.Autograd_Explained",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"17",
      "executedFeatures":[{"id":"Simple automatic differentiation and propagation.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.autograd.internal.GraphNode_Tensor_Exception_Unit_Tests",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"568",
      "executedFeatures":[{"id":"A tensor cannot be deleted if it is part of a graph and the tensor is used as derivative.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.backend.core.Backend_Algorithm_Implementation_Spec",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"342",
      "executedFeatures":[{"id":"Activation implementations have expected Executor instances.","extraInfo":[]},{"id":"CLExecutors of Operator implementations behave as expected.","extraInfo":[]},{"id":"HostExecutors of Operator implementations behave as expected.","extraInfo":[]},{"id":"Operator implementations have expected Executor instances.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.Calculus_Parsing_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"42",
      "executedFeatures":[{"id":"Functions can derive themselves according to the provided index of the input which ought to be derived.","extraInfo":[]},{"id":"Parsed equations throw expected error messages.","extraInfo":[]},{"id":"Test parsed equations when building Function instances.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.calculus.ConCat_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"64",
      "executedFeatures":[{"id":"We can concatenate 2 float tensors alongside a specified axis!","extraInfo":[]},{"id":"We can concatenate 2 string tensors alongside a specified axis!","extraInfo":[]},{"id":"We can concatenate 2 tensors alongside a specified axis!","extraInfo":[]},{"id":"We can concatenate and then back-propagate 2 simple float tensors alongside a specified axis!","extraInfo":[]},{"id":"We can concatenate and then back-propagate 3 simple float tensors alongside a specified axis!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.CLFunctionCompiler_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"152",
      "executedFeatures":[{"id":"The OpenCLDevice produces a working optimized Function (internally using the CLFunctionCompiler).","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.device.OpenCL_Spec",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"2607",
      "executedFeatures":[{"id":"A given OpenCL context can be disposed!","extraInfo":[]},{"id":"An OpenCLDevice will throw an exception when trying to add a tensor whose \"data parent\" is not outsourced.","extraInfo":[]},{"id":"First found OpenCLDevice will have realistic numeric properties.","extraInfo":[]},{"id":"First found OpenCLDevice will have realistic properties inside summary query.","extraInfo":[]},{"id":"First found OpenCLDevice will have realistic text properties.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.ndim.NDConfiguration_Spec",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"72",
      "executedFeatures":[{"id":"Various NDConfigurations behaviour exactly as their general purpose implementation.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.tensors.Copy_Spec",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"20",
      "executedFeatures":[{"id":"A deep copy of a slice tensor is also a deep copy of the underlying data array.","extraInfo":[]},{"id":"A deep copy of a tensor is also a deep copy of the underlying data array.","extraInfo":[]},{"id":"A shallow copy will share the same underlying data as its original tensor.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"ut.utility.ListReader_Exception_Spec",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"10",
      "executedFeatures":[{"id":"The ListReader will detect inconsistent degrees of nesting in the provided data.","extraInfo":[]},{"id":"The ListReader will detect inconsistent types in the provided data.","extraInfo":[]}],
      "ignoredFeatures":[]
    }
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}