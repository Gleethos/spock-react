{
  "className":"it.Calculus_Stress_Test",
  "statistics":{
    "runs":"5",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"3.749 seconds"
  },

  "title":"",
  "narrative":"",
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Stress test runs error free and produces expected result",
      "result":"PASS",
      "duration":"1.059 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"----","code":[""]},
        {"kind":"when","text":"----","code":[""]},
        {"kind":"then","text":"----","code":[""]},
        {"kind":"when","text":"----","code":[""]},
        {"kind":"then","text":"----","code":[""]},
        {"kind":"where","text":"----","code":[""]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Dot operation stress test runs error free and produces expected result",
      "result":"PASS",
      "duration":"0.064 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["Tsr<Double> t = Tsr.of( shape, -4d..2d )"]},
        {"kind":"when","text":"","code":["t = t.convDot( t.T() )"]},
        {"kind":"then","text":"","code":["t.toString() == expected"]},
        {"kind":"where","text":"","code":[""]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"The broadcast operation stress test runs error free and produces expected result",
      "result":"PASS",
      "duration":"0.131 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"----","code":[""]},
        {"kind":"when","text":"----","code":[""]},
        {"kind":"then","text":"----","code":[""]},
        {"kind":"where","text":"----","code":[""]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Activation functions work across types, on large prime sized 1D slices and non sliced 1D tensors.",
      "result":"PASS",
      "duration":"1.706 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a function based on the provided expression.","code":["var func = Function.of(funExpression)"]},
        {"kind":"and","text":"We use a large prime number to size our tensors in order to stress workload divisibility.","code":["var PRIME_SIZE_1 = 7907","var PRIME_SIZE_2 = 7919"]},
        {"kind":"and","text":"We create 2 tensors storing the same values, one sliced and the other a normal tensor.","code":["var t1 = Tsr.of(type).withShape(PRIME_SIZE_1).andSeed(\"Tempeh\")","var t2 = Tsr.of(type).withShape(PRIME_SIZE_2).all(0)[9..7915]","t2[0..t2.size-1] = t1"]},
        {"kind":"expect","text":"The types of both tensors should match what was provided during instantiation.","code":["t1.dataType == DataType.of(type)","t1.itemClass == type","t2.dataType == DataType.of(type)","t2.itemClass == type"]},
        {"kind":"when","text":"We apply the function to both tensors...","code":["var result1 = func(t1)","var result2 = func(t2)"]},
        {"kind":"then","text":"First we ensure that both tensors have the correct value/element type.","code":["result1.itemClass == type","result2.itemClass == type"]},
        {"kind":"and","text":"The underlying data object should match the data array type as is defined by the data type!","code":["result1.unsafe.data.class == result1.dataType.dataArrayType()","result2.unsafe.data.class == result2.dataType.dataArrayType()"]},
        {"kind":"and","text":"The data of the first non slice tensor as well as its slice should be as expected.","code":["Arrays.hashCode(result1.unsafe.data) == expected[0]","Arrays.hashCode(result2.unsafe.data) == expected[1]"]},
        {"kind":"where","text":"","code":[""]}
      ],
      "problems":"[]"
    },
  
    {
      "id":"Activation functions work across types.",
      "result":"PASS",
      "duration":"0.180 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a function based on the provided expression.","code":["var func = Function.of(funExpression)"]},
        {"kind":"and","text":"We use a large prime number to size our tensors in order to stress workload divisibility.","code":["var PRIME_SIZE_1 = 3","var PRIME_SIZE_2 = 5"]},
        {"kind":"and","text":"We create 2 tensors storing the same values, one sliced and the other a normal tensor.","code":["var t1 = Tsr.of(type).withShape(PRIME_SIZE_1).andSeed(\"Seitan\")","var t2 = Tsr.of(type).withShape(PRIME_SIZE_2).all(0)[1..3]","t2[0..t2.size-1] = t1"]},
        {"kind":"expect","text":"The types of both tensors should match what was provided during instantiation.","code":["t1.dataType   == DataType.of(type)","t1.itemClass == type","t2.dataType   == DataType.of(type)","t2.itemClass == type"]},
        {"kind":"when","text":"We apply the function to both tensors...","code":["var result1 = ( !derive ? func(t1) : func.derive([t1], 0) )","var result2 = ( !derive ? func(t2) : func.derive([t2], 0) )"]},
        {"kind":"then","text":"First we ensure that both tensors have the correct value/element type.","code":["result1.itemClass == type","result2.itemClass == type"]},
        {"kind":"and","text":"The underlying data object should match the data array type as is defined by the data type!","code":["result1.unsafe.data.class == result1.dataType.dataArrayType()","result2.unsafe.data.class == result2.dataType.dataArrayType()"]},
        {"kind":"and","text":"The data of the first non slice tensor as well as its slice should be as expected.","code":["result1.items == expected","result2.items == expected"]},
        {"kind":"where","text":"","code":[""]}
      ],
      "problems":"[]"
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}